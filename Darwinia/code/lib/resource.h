/*
 * RESOURCE SYSTEM
 *
 */

#ifndef _included_resource_h
#define _included_resource_h

#include <unrar.h>
#include <string>

#include "lib/btree.h"
#include "lib/llist.h"
#include "lib/fast_darray.h"
#include "lib/hash_table.h"


class Shape;
class BitmapRGBA;
class TextReader;
class BinaryReader;
class SoundStreamDecoder;
class GestureDemo;
class Resource;
class FileWriter;


class Resource
{
protected:
	unsigned int				m_nameSeed;

	// The RAR archive decompressed into RAM
	BTree<MemMappedFile *>		m_resourceFiles;

	// Bitmaps that have been registered with the resource system, so that
	// they can be used as if they had been loaded from disk or the archive.
	// USUALLY USED for AUTOGENERATED bitmaps, so that the resource system
	// can regenerate textures for them when the OpenGL context is destroyed.
	HashTable<BitmapRGBA *>		m_bitmaps;

	HashTable<int>				m_displayLists;

	HashTable<int>				m_textures;
	HashTable<Shape *>			m_shapes;
	HashTable<GestureDemo *>	m_gestureDemos;

    char                        *m_modName;

	int WildCmp							(char const *_wild, char const *_string);

public:
	// *** Initialisation/Destruction ***
    Resource();
	~Resource();
    void            ParseArchive		( char const *_dataFile, char const *_password);

	// *** Bitmaps ***
    void            AddBitmap			(char const *_name, BitmapRGBA const &_bmp, bool _mipMapping=true);
	BitmapRGBA const*GetBitmap			(char const *_name);
	void			DeleteBitmap		(char const *_name);

	// *** Textures ***
	int             GetTexture			(char const *_name, bool _mipMapping=true, bool _masked=true);
    bool            DoesTextureExist    (char const *_name);
	void			DeleteTexture		(char const *_name);

	// *** Files ***
	MemMappedFile	*GetUncompressedFile(char const *_filename);
	TextReader		*GetTextReader	    (std::string const &_filename);	// Caller must delete the TextReader when done
	TextReader		*GetTextReader	    (char const *_filename);	// Caller must delete the TextReader when done
	BinaryReader	*GetBinaryReader    (char const *_filename);	// Caller must delete the BinaryReader when done
    FileWriter      *GetFileWriter      (char const *_filename, bool _encrypt);

	// *** Shapes ****
	Shape			*GetShape			(char const *_name);		// Never produces an animatable shape because the one shape is shared between all people who call this function with the same shape name. If you want an animatable shape, call GetShapeCopy
	Shape			*GetShape			(char const *_name, char _teamID, bool _animating); // Never produces an animatable shape because the one shape is shared between all people who call this function with the same shape name. If you want an animatable shape, call GetShapeCopy
	Shape			*GetShapeCopy		(char const *_name, bool _animating);

	// *** Normal resources ***
	SoundStreamDecoder *GetSoundStreamDecoder(char const *_filename);	// Caller must delete the decoder when done
	GestureDemo		*GetGestureDemo		(char const *_name);

	// *** Display lists ***
	int				CreateDisplayList	(char const *_name);	// Adds _name to the hashtable and calls glGenLists
	int				GetDisplayList		(char const *_name);	// Returns -1 if _name doesn't exist
	void			DeleteDisplayList	(char const *_name);	// Removes _name from the hashtable and calls glDeleteLists

    void			FlushOpenGlState	();
	void			RegenerateOpenGlState();

	// Returns a unique name that can be used to identify autogenerated resources. It is the caller's
	// responsibility to delete the name later. Use "delete []" NOT "free".
	char			*GenerateName		();

    void            LoadMod             (char const *_modName);
    bool            IsModLoaded         ();
    char            *GetBaseDirectory   ();
	const char      *GetModName			();

	LList <char *> *ListResources(char const *_dir, char const *_filter, bool _longResults = true);
};



#endif
